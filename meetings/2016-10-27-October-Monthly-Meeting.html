<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>San Diego FP - October Monthly Meeting</title>
    <link rel="stylesheet" type="text/css" href="../static/css/main.css" />
  </head>
  <body>
    <header>
      <h1>
        <img src="../static/img/fplogo_small.png" />
        <a href="../">San Diego Functional Programmers</a>
      </h1>
      <navigation>
        <ul>
          <li><a href="../#about">About</a></li>
          <li><a href="../#events">Events</a></li>
          <li><a href="../#speak">Speak</a></li>
          <li><a href="../#contact">Contact</a></li>
        </ul>
      </navigation>
    </header>
    <article id="content">
      <h1>October Monthly Meeting</h1>

<div class="info">
    Posted on October 27, 2016
    
</div>

<article class="post-content">
  <p>This month we have talk and a kata!</p>
<h2 id="talk---purescript-pux">Talk - PureScript &amp; Pux</h2>
<p>Speaker - Jesse Williamson</p>
<p>Functional programming is becoming very popular on the frontend. Libraries like React and Redux have done a lot to push functional ideals like purity &amp; immutability into the mainstream. What about taking it even further? You may have heard of Elm and the number of benefits developers are getting using it. PureScript is another alternative to JavaScript. It is statically typed, and purely function like Elm, but is offers a few more features that make it a more powerful language. We’ll take a look at the basics of the language, some of those extra features, and one of the libraries available for writing web frontends: Pux.</p>
<h2 id="kata">Kata</h2>
<h3 id="kata-1---huttons-razor">Kata 1 - Hutton’s Razor++</h3>
<p>This kata is a slightly modified version of Huttons Razor, taken from <a href="http://www.codewars.com/kata/543833d86f032f0942000264">Code Wars</a>, and is also described in the <a href="http://www.cs.nott.ac.uk/~pszgmh/semantics.pdf">this paper</a></p>
<p>We’re are going to describe a syntax tree for a simple language that has exactly three pieces: literal integers, and addition operation, and a multiplication operation.</p>
<p>Below is an example recursive data type (in Haskell) to model the AST:</p>
<pre><code>data Expr =
    Lit Integer
  | Add Expr Expr
  | Mul Expr Expr</code></pre>
<ol style="list-style-type: decimal">
<li><p>Implement an interpreter for this language. For example the program <code>Mul (Lit 2) (Add (Lit 2) (Lit 3))</code> would return <code>10</code>.</p></li>
<li><p>Implement a pretty-printer; surround all <code>Add</code> operations with parenthesis. Spaces are not necessary. For example, the program <code>Mul (Lit 1) (Lit 2)</code> would return <code>&quot;(1 * 2)&quot;</code></p></li>
</ol>
<h3 id="kata-2---oragami">Kata 2 - Oragami</h3>
<p>Folds are a family higher-order functions that process a data structure and build up a return value. Many different data structures can be folded, but we’ll focus on lists for now.</p>
<p>The <code>foldr</code> function processes a list from right to left using an accumulator function and and initial value. In Haskell, the type of <code>foldr</code> (when constrained to lists) looks like this:</p>
<pre><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></pre>
<p>The function <code>foldl</code> is very much like <code>foldr</code> but with a <a href="https://%20wiki.haskell.org/Foldr_Foldl_Foldl'">few differences</a>. Among those differences is the order of arguments to the accumulator function, and the fact that the list is process from left to right. The type of <code>foldl</code> looks like this:</p>
<pre><code>foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></pre>
<ol style="list-style-type: decimal">
<li><p>Implement <code>foldr</code>.</p></li>
<li><p>Implement <code>foldrl</code></p></li>
<li><p>Folds are the basis for many of the most commonly know functions in FP. You can use it to define <code>map</code>, <code>filter</code>, etc. Define the following list functions using <code>foldr</code> or <code>foldl</code></p></li>
</ol>
<ul>
<li><code>sum</code>, which calculates the sum of a list of integers</li>
<li><code>length</code>, which returns the number of elements in a list</li>
<li><code>minList</code> &amp; <code>maxList</code>, which return the smallest and largest elements in a list of integers.</li>
<li><code>reverse</code>, which reverse a list</li>
<li><code>map</code>, which takes a function that transforms an element of type <code>a</code> into an element of type <code>b</code>, and a list of elements of type <code>a</code>, then returns a list of type <code>b</code></li>
<li><code>inits</code>, which returns all of the initial segments of a list. For example: <code>inits [1, 2, 3] = [[], [1], [1, 2], [1, 2, 3]]</code></li>
</ul>
</article>

    </article>
    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
</html>
